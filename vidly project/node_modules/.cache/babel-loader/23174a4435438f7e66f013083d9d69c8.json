{"ast":null,"code":"var utils = require('../../src/utils');\n/*\n TraceKit - Cross brower stack traces\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\n\n\nvar TraceKit = {\n  collectWindowErrors: true,\n  debug: false\n}; // This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\n\nvar _window = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {}; // global reference to slice\n\n\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?'; // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\n\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\nfunction getLocationHref() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n  return document.location.href;\n}\n\nfunction getLocationOrigin() {\n  if (typeof document === 'undefined' || document.location == null) return ''; // Oh dear IE10...\n\n  if (!document.location.origin) {\n    return document.location.protocol + '//' + document.location.hostname + (document.location.port ? ':' + document.location.port : '');\n  }\n\n  return document.location.origin;\n}\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\n\n\nTraceKit.report = function reportModuleWrapper() {\n  var handlers = [],\n      lastArgs = null,\n      lastException = null,\n      lastExceptionStack = null;\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   */\n\n  function subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n  }\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   */\n\n\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n  /**\n   * Remove all crash handlers.\n   */\n\n\n  function unsubscribeAll() {\n    uninstallGlobalHandler();\n    handlers = [];\n  }\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {Object.<string, *>} stack\n   */\n\n\n  function notifyHandlers(stack, isWindowError) {\n    var exception = null;\n\n    if (isWindowError && !TraceKit.collectWindowErrors) {\n      return;\n    }\n\n    for (var i in handlers) {\n      if (handlers.hasOwnProperty(i)) {\n        try {\n          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n\n    if (exception) {\n      throw exception;\n    }\n  }\n\n  var _oldOnerrorHandler, _onErrorHandlerInstalled;\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {string} msg Error message.\n   * @param {string} url URL of script that generated the exception.\n   * @param {(number|string)} lineNo The line number at which the error\n   * occurred.\n   * @param {?(number|string)} colNo The column number at which the error\n   * occurred.\n   * @param {?Error} ex The actual Error object.\n   */\n\n\n  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n    var stack = null; // If 'ex' is ErrorEvent, get real Error from inside\n\n    var exception = utils.isErrorEvent(ex) ? ex.error : ex; // If 'msg' is ErrorEvent, get real message from inside\n\n    var message = utils.isErrorEvent(msg) ? msg.message : msg;\n\n    if (lastExceptionStack) {\n      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(lastExceptionStack, url, lineNo, message);\n      processLastException();\n    } else if (exception && utils.isError(exception)) {\n      // non-string `exception` arg; attempt to extract stack trace\n      // New chrome and blink send along a real error object\n      // Let's just report that like a normal error.\n      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n      stack = TraceKit.computeStackTrace(exception);\n      notifyHandlers(stack, true);\n    } else {\n      var location = {\n        url: url,\n        line: lineNo,\n        column: colNo\n      };\n      var name = undefined;\n      var groups;\n\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = message.match(ERROR_TYPES_RE);\n\n        if (groups) {\n          name = groups[1];\n          message = groups[2];\n        }\n      }\n\n      location.func = UNKNOWN_FUNCTION;\n      stack = {\n        name: name,\n        message: message,\n        url: getLocationHref(),\n        stack: [location]\n      };\n      notifyHandlers(stack, true);\n    }\n\n    if (_oldOnerrorHandler) {\n      return _oldOnerrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  }\n\n  function installGlobalHandler() {\n    if (_onErrorHandlerInstalled) {\n      return;\n    }\n\n    _oldOnerrorHandler = _window.onerror;\n    _window.onerror = traceKitWindowOnError;\n    _onErrorHandlerInstalled = true;\n  }\n\n  function uninstallGlobalHandler() {\n    if (!_onErrorHandlerInstalled) {\n      return;\n    }\n\n    _window.onerror = _oldOnerrorHandler;\n    _onErrorHandlerInstalled = false;\n    _oldOnerrorHandler = undefined;\n  }\n\n  function processLastException() {\n    var _lastExceptionStack = lastExceptionStack,\n        _lastArgs = lastArgs;\n    lastArgs = null;\n    lastExceptionStack = null;\n    lastException = null;\n    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n  }\n  /**\n   * Reports an unhandled Error to TraceKit.\n   * @param {Error} ex\n   * @param {?boolean} rethrow If false, do not re-throw the exception.\n   * Only used for window.onerror to not cause an infinite loop of\n   * rethrowing.\n   */\n\n\n  function report(ex, rethrow) {\n    var args = _slice.call(arguments, 1);\n\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      } else {\n        processLastException();\n      }\n    }\n\n    var stack = TraceKit.computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex;\n    lastArgs = args; // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n\n    setTimeout(function () {\n      if (lastException === ex) {\n        processLastException();\n      }\n    }, stack.incomplete ? 2000 : 0);\n\n    if (rethrow !== false) {\n      throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n  }\n\n  report.subscribe = subscribe;\n  report.unsubscribe = unsubscribe;\n  report.uninstall = unsubscribeAll;\n  return report;\n}();\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\n\n\nTraceKit.computeStackTrace = function computeStackTraceWrapper() {\n  // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceFromStackProp(ex) {\n    if (typeof ex.stack === 'undefined' || !ex.stack) return;\n    var chrome = /^\\s*at (?:(.*?) ?\\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i; // NOTE: blob urls are now supposed to always have an origin, therefore it's format\n    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\\/` as well\n\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\\/.*?|\\[native code\\]|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i; // Used to additionally parse URL/line/column from eval frames\n\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = ex.stack.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n    var reference = /^(.*) is undefined$/.exec(ex.message);\n\n    for (var i = 0, j = lines.length; i < j; ++i) {\n      if (parts = chrome.exec(lines[i])) {\n        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n\n        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n\n        if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n          // throw out eval line/column and use top-most line/column number\n          parts[2] = submatch[1]; // url\n\n          parts[3] = submatch[2]; // line\n\n          parts[4] = submatch[3]; // column\n        }\n\n        element = {\n          url: !isNative ? parts[2] : null,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: isNative ? [parts[2]] : [],\n          line: parts[3] ? +parts[3] : null,\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if (parts = winjs.exec(lines[i])) {\n        element = {\n          url: parts[2],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: [],\n          line: +parts[3],\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if (parts = gecko.exec(lines[i])) {\n        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n\n        if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n          // throw out eval line/column and use top-most line number\n          parts[3] = submatch[1];\n          parts[4] = submatch[2];\n          parts[5] = null; // no column when eval\n        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {\n          // FireFox uses this awesome columnNumber property for its top frame\n          // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n          // so adding 1\n          // NOTE: this hack doesn't work if top-most frame is eval\n          stack[0].column = ex.columnNumber + 1;\n        }\n\n        element = {\n          url: parts[3],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: parts[2] ? parts[2].split(',') : [],\n          line: parts[4] ? +parts[4] : null,\n          column: parts[5] ? +parts[5] : null\n        };\n      } else {\n        continue;\n      }\n\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n\n      if (element.url && element.url.substr(0, 5) === 'blob:') {\n        // Special case for handling JavaScript loaded into a blob.\n        // We use a synchronous AJAX request here as a blob is already in\n        // memory - it's not making a network request.  This will generate a warning\n        // in the browser console, but there has already been an error so that's not\n        // that much of an issue.\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', element.url, false);\n        xhr.send(null); // If we failed to download the source, skip this patch\n\n        if (xhr.status === 200) {\n          var source = xhr.responseText || ''; // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.\n          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175\n\n          source = source.slice(-300); // Now we dig out the source map URL\n\n          var sourceMaps = source.match(/\\/\\/# sourceMappingURL=(.*)$/); // If we don't find a source map comment or we find more than one, continue on to the next element.\n\n          if (sourceMaps) {\n            var sourceMapAddress = sourceMaps[1]; // Now we check to see if it's a relative URL.\n            // If it is, convert it to an absolute one.\n\n            if (sourceMapAddress.charAt(0) === '~') {\n              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);\n            } // Now we strip the '.map' off of the end of the URL and update the\n            // element so that Sentry can match the map to the blob.\n\n\n            element.url = sourceMapAddress.slice(0, -4);\n          }\n        }\n      }\n\n      stack.push(element);\n    }\n\n    if (!stack.length) {\n      return null;\n    }\n\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n  }\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {Object.<string, *>} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string} url The URL of the script that caused an error.\n   * @param {(number|string)} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   */\n\n\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      url: url,\n      line: lineNo\n    };\n\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n\n      if (!initial.func) {\n        initial.func = UNKNOWN_FUNCTION;\n      }\n\n      if (stackInfo.stack.length > 0) {\n        if (stackInfo.stack[0].url === initial.url) {\n          if (stackInfo.stack[0].line === initial.line) {\n            return false; // already in stack trace\n          } else if (!stackInfo.stack[0].line && stackInfo.stack[0].func === initial.func) {\n            stackInfo.stack[0].line = initial.line;\n            return false;\n          }\n        }\n      }\n\n      stackInfo.stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    } else {\n      stackInfo.incomplete = true;\n    }\n\n    return false;\n  }\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n\n\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n        stack = [],\n        funcs = {},\n        recursion = false,\n        parts,\n        item,\n        source;\n\n    for (var curr = computeStackTraceByWalkingCallerChain.caller; curr && !recursion; curr = curr.caller) {\n      if (curr === computeStackTrace || curr === TraceKit.report) {\n        // console.log('skipping internal function');\n        continue;\n      }\n\n      item = {\n        url: null,\n        func: UNKNOWN_FUNCTION,\n        line: null,\n        column: null\n      };\n\n      if (curr.name) {\n        item.func = curr.name;\n      } else if (parts = functionName.exec(curr.toString())) {\n        item.func = parts[1];\n      }\n\n      if (typeof item.func === 'undefined') {\n        try {\n          item.func = parts.input.substring(0, parts.input.indexOf('{'));\n        } catch (e) {}\n      }\n\n      if (funcs['' + curr]) {\n        recursion = true;\n      } else {\n        funcs['' + curr] = true;\n      }\n\n      stack.push(item);\n    }\n\n    if (depth) {\n      // console.log('depth is ' + depth);\n      // console.log('stack is ' + stack.length);\n      stack.splice(0, depth);\n    }\n\n    var result = {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n    augmentStackTraceWithInitialElement(result, ex.sourceURL || ex.fileName, ex.line || ex.lineNumber, ex.message || ex.description);\n    return result;\n  }\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   */\n\n\n  function computeStackTrace(ex, depth) {\n    var stack = null;\n    depth = depth == null ? 0 : +depth;\n\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref()\n    };\n  }\n\n  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n  return computeStackTrace;\n}();\n\nmodule.exports = TraceKit;","map":{"version":3,"sources":["/Users/melikekilic/vidly/vidly project/node_modules/raven-js/vendor/TraceKit/tracekit.js"],"names":["utils","require","TraceKit","collectWindowErrors","debug","_window","window","global","self","_slice","slice","UNKNOWN_FUNCTION","ERROR_TYPES_RE","getLocationHref","document","location","href","getLocationOrigin","origin","protocol","hostname","port","report","reportModuleWrapper","handlers","lastArgs","lastException","lastExceptionStack","subscribe","handler","installGlobalHandler","push","unsubscribe","i","length","splice","unsubscribeAll","uninstallGlobalHandler","notifyHandlers","stack","isWindowError","exception","hasOwnProperty","apply","concat","call","arguments","inner","_oldOnerrorHandler","_onErrorHandlerInstalled","traceKitWindowOnError","msg","url","lineNo","colNo","ex","isErrorEvent","error","message","computeStackTrace","augmentStackTraceWithInitialElement","processLastException","isError","line","column","name","undefined","groups","toString","match","func","onerror","_lastExceptionStack","_lastArgs","rethrow","args","setTimeout","incomplete","uninstall","computeStackTraceWrapper","computeStackTraceFromStackProp","chrome","winjs","gecko","geckoEval","chromeEval","lines","split","submatch","parts","element","reference","exec","j","isNative","indexOf","isEval","columnNumber","substr","xhr","XMLHttpRequest","open","send","status","source","responseText","sourceMaps","sourceMapAddress","charAt","stackInfo","initial","unshift","partial","computeStackTraceByWalkingCallerChain","depth","functionName","funcs","recursion","item","curr","caller","input","substring","e","result","sourceURL","fileName","lineNumber","description","module","exports"],"mappings":"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","sourcesContent":["var utils = require('../../src/utils');\n\n/*\n TraceKit - Cross brower stack traces\n\n This was originally forked from github.com/occ/TraceKit, but has since been\n largely re-written and is now maintained as part of raven-js.  Tests for\n this are in test/vendor.\n\n MIT license\n*/\n\nvar TraceKit = {\n  collectWindowErrors: true,\n  debug: false\n};\n\n// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)\nvar _window =\n  typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n// global reference to slice\nvar _slice = [].slice;\nvar UNKNOWN_FUNCTION = '?';\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types\nvar ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;\n\nfunction getLocationHref() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n  return document.location.href;\n}\n\nfunction getLocationOrigin() {\n  if (typeof document === 'undefined' || document.location == null) return '';\n\n  // Oh dear IE10...\n  if (!document.location.origin) {\n    return (\n      document.location.protocol +\n      '//' +\n      document.location.hostname +\n      (document.location.port ? ':' + document.location.port : '')\n    );\n  }\n\n  return document.location.origin;\n}\n\n/**\n * TraceKit.report: cross-browser processing of unhandled exceptions\n *\n * Syntax:\n *   TraceKit.report.subscribe(function(stackInfo) { ... })\n *   TraceKit.report.unsubscribe(function(stackInfo) { ... })\n *   TraceKit.report(exception)\n *   try { ...code... } catch(ex) { TraceKit.report(ex); }\n *\n * Supports:\n *   - Firefox: full stack trace with line numbers, plus column number\n *              on top frame; column number is not guaranteed\n *   - Opera:   full stack trace with line and column numbers\n *   - Chrome:  full stack trace with line and column numbers\n *   - Safari:  line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *   - IE:      line and column number for the top frame only; some frames\n *              may be missing, and column number is not guaranteed\n *\n * In theory, TraceKit should work on all of the following versions:\n *   - IE5.5+ (only 8.0 tested)\n *   - Firefox 0.9+ (only 3.5+ tested)\n *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require\n *     Exceptions Have Stacktrace to be enabled in opera:config)\n *   - Safari 3+ (only 4+ tested)\n *   - Chrome 1+ (only 5+ tested)\n *   - Konqueror 3.5+ (untested)\n *\n * Requires TraceKit.computeStackTrace.\n *\n * Tries to catch all unhandled exceptions and report them to the\n * subscribed handlers. Please note that TraceKit.report will rethrow the\n * exception. This is REQUIRED in order to get a useful stack trace in IE.\n * If the exception does not reach the top of the browser, you will only\n * get a stack trace from the point where TraceKit.report was called.\n *\n * Handlers receive a stackInfo object as described in the\n * TraceKit.computeStackTrace docs.\n */\nTraceKit.report = (function reportModuleWrapper() {\n  var handlers = [],\n    lastArgs = null,\n    lastException = null,\n    lastExceptionStack = null;\n\n  /**\n   * Add a crash handler.\n   * @param {Function} handler\n   */\n  function subscribe(handler) {\n    installGlobalHandler();\n    handlers.push(handler);\n  }\n\n  /**\n   * Remove a crash handler.\n   * @param {Function} handler\n   */\n  function unsubscribe(handler) {\n    for (var i = handlers.length - 1; i >= 0; --i) {\n      if (handlers[i] === handler) {\n        handlers.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Remove all crash handlers.\n   */\n  function unsubscribeAll() {\n    uninstallGlobalHandler();\n    handlers = [];\n  }\n\n  /**\n   * Dispatch stack information to all handlers.\n   * @param {Object.<string, *>} stack\n   */\n  function notifyHandlers(stack, isWindowError) {\n    var exception = null;\n    if (isWindowError && !TraceKit.collectWindowErrors) {\n      return;\n    }\n    for (var i in handlers) {\n      if (handlers.hasOwnProperty(i)) {\n        try {\n          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));\n        } catch (inner) {\n          exception = inner;\n        }\n      }\n    }\n\n    if (exception) {\n      throw exception;\n    }\n  }\n\n  var _oldOnerrorHandler, _onErrorHandlerInstalled;\n\n  /**\n   * Ensures all global unhandled exceptions are recorded.\n   * Supported by Gecko and IE.\n   * @param {string} msg Error message.\n   * @param {string} url URL of script that generated the exception.\n   * @param {(number|string)} lineNo The line number at which the error\n   * occurred.\n   * @param {?(number|string)} colNo The column number at which the error\n   * occurred.\n   * @param {?Error} ex The actual Error object.\n   */\n  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {\n    var stack = null;\n    // If 'ex' is ErrorEvent, get real Error from inside\n    var exception = utils.isErrorEvent(ex) ? ex.error : ex;\n    // If 'msg' is ErrorEvent, get real message from inside\n    var message = utils.isErrorEvent(msg) ? msg.message : msg;\n\n    if (lastExceptionStack) {\n      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(\n        lastExceptionStack,\n        url,\n        lineNo,\n        message\n      );\n      processLastException();\n    } else if (exception && utils.isError(exception)) {\n      // non-string `exception` arg; attempt to extract stack trace\n\n      // New chrome and blink send along a real error object\n      // Let's just report that like a normal error.\n      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror\n      stack = TraceKit.computeStackTrace(exception);\n      notifyHandlers(stack, true);\n    } else {\n      var location = {\n        url: url,\n        line: lineNo,\n        column: colNo\n      };\n\n      var name = undefined;\n      var groups;\n\n      if ({}.toString.call(message) === '[object String]') {\n        var groups = message.match(ERROR_TYPES_RE);\n        if (groups) {\n          name = groups[1];\n          message = groups[2];\n        }\n      }\n\n      location.func = UNKNOWN_FUNCTION;\n\n      stack = {\n        name: name,\n        message: message,\n        url: getLocationHref(),\n        stack: [location]\n      };\n      notifyHandlers(stack, true);\n    }\n\n    if (_oldOnerrorHandler) {\n      return _oldOnerrorHandler.apply(this, arguments);\n    }\n\n    return false;\n  }\n\n  function installGlobalHandler() {\n    if (_onErrorHandlerInstalled) {\n      return;\n    }\n    _oldOnerrorHandler = _window.onerror;\n    _window.onerror = traceKitWindowOnError;\n    _onErrorHandlerInstalled = true;\n  }\n\n  function uninstallGlobalHandler() {\n    if (!_onErrorHandlerInstalled) {\n      return;\n    }\n    _window.onerror = _oldOnerrorHandler;\n    _onErrorHandlerInstalled = false;\n    _oldOnerrorHandler = undefined;\n  }\n\n  function processLastException() {\n    var _lastExceptionStack = lastExceptionStack,\n      _lastArgs = lastArgs;\n    lastArgs = null;\n    lastExceptionStack = null;\n    lastException = null;\n    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));\n  }\n\n  /**\n   * Reports an unhandled Error to TraceKit.\n   * @param {Error} ex\n   * @param {?boolean} rethrow If false, do not re-throw the exception.\n   * Only used for window.onerror to not cause an infinite loop of\n   * rethrowing.\n   */\n  function report(ex, rethrow) {\n    var args = _slice.call(arguments, 1);\n    if (lastExceptionStack) {\n      if (lastException === ex) {\n        return; // already caught by an inner catch block, ignore\n      } else {\n        processLastException();\n      }\n    }\n\n    var stack = TraceKit.computeStackTrace(ex);\n    lastExceptionStack = stack;\n    lastException = ex;\n    lastArgs = args;\n\n    // If the stack trace is incomplete, wait for 2 seconds for\n    // slow slow IE to see if onerror occurs or not before reporting\n    // this exception; otherwise, we will end up with an incomplete\n    // stack trace\n    setTimeout(function() {\n      if (lastException === ex) {\n        processLastException();\n      }\n    }, stack.incomplete ? 2000 : 0);\n\n    if (rethrow !== false) {\n      throw ex; // re-throw to propagate to the top level (and cause window.onerror)\n    }\n  }\n\n  report.subscribe = subscribe;\n  report.unsubscribe = unsubscribe;\n  report.uninstall = unsubscribeAll;\n  return report;\n})();\n\n/**\n * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript\n *\n * Syntax:\n *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)\n * Returns:\n *   s.name              - exception name\n *   s.message           - exception message\n *   s.stack[i].url      - JavaScript or HTML file URL\n *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)\n *   s.stack[i].args     - arguments passed to the function, if known\n *   s.stack[i].line     - line number, if known\n *   s.stack[i].column   - column number, if known\n *\n * Supports:\n *   - Firefox:  full stack trace with line numbers and unreliable column\n *               number on top frame\n *   - Opera 10: full stack trace with line and column numbers\n *   - Opera 9-: full stack trace with line numbers\n *   - Chrome:   full stack trace with line and column numbers\n *   - Safari:   line and column number for the topmost stacktrace element\n *               only\n *   - IE:       no line numbers whatsoever\n *\n * Tries to guess names of anonymous functions by looking for assignments\n * in the source code. In IE and Safari, we have to guess source file names\n * by searching for function bodies inside all page scripts. This will not\n * work for scripts that are loaded cross-domain.\n * Here be dragons: some function names may be guessed incorrectly, and\n * duplicate functions may be mismatched.\n *\n * TraceKit.computeStackTrace should only be used for tracing purposes.\n * Logging of unhandled exceptions should be done with TraceKit.report,\n * which builds on top of TraceKit.computeStackTrace and provides better\n * IE support by utilizing the window.onerror event to retrieve information\n * about the top of the stack.\n *\n * Note: In IE and Safari, no stack trace is recorded on the Error object,\n * so computeStackTrace instead walks its *own* chain of callers.\n * This means that:\n *  * in Safari, some methods may be missing from the stack trace;\n *  * in IE, the topmost function in the stack trace will always be the\n *    caller of computeStackTrace.\n *\n * This is okay for tracing (because you are likely to be calling\n * computeStackTrace from the function you want to be the topmost element\n * of the stack trace anyway), but not okay for logging unhandled\n * exceptions (because your catch block will likely be far away from the\n * inner function that actually caused the exception).\n *\n */\nTraceKit.computeStackTrace = (function computeStackTraceWrapper() {\n  // Contents of Exception in various browsers.\n  //\n  // SAFARI:\n  // ex.message = Can't find variable: qq\n  // ex.line = 59\n  // ex.sourceId = 580238192\n  // ex.sourceURL = http://...\n  // ex.expressionBeginOffset = 96\n  // ex.expressionCaretOffset = 98\n  // ex.expressionEndOffset = 98\n  // ex.name = ReferenceError\n  //\n  // FIREFOX:\n  // ex.message = qq is not defined\n  // ex.fileName = http://...\n  // ex.lineNumber = 59\n  // ex.columnNumber = 69\n  // ex.stack = ...stack trace... (see the example below)\n  // ex.name = ReferenceError\n  //\n  // CHROME:\n  // ex.message = qq is not defined\n  // ex.name = ReferenceError\n  // ex.type = not_defined\n  // ex.arguments = ['aa']\n  // ex.stack = ...stack trace...\n  //\n  // INTERNET EXPLORER:\n  // ex.message = ...\n  // ex.name = ReferenceError\n  //\n  // OPERA:\n  // ex.message = ...message... (see the example below)\n  // ex.name = ReferenceError\n  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)\n  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'\n\n  /**\n   * Computes stack trace information from the stack property.\n   * Chrome and Gecko use this property.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceFromStackProp(ex) {\n    if (typeof ex.stack === 'undefined' || !ex.stack) return;\n\n    var chrome = /^\\s*at (?:(.*?) ?\\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\\/).*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\n    var winjs = /^\\s*at (?:((?:\\[object object\\])?.+) )?\\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\\d+)(?::(\\d+))?\\)?\\s*$/i;\n    // NOTE: blob urls are now supposed to always have an origin, therefore it's format\n    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\\/` as well\n    var gecko = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\\/.*?|\\[native code\\]|[^@]*bundle)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\n    // Used to additionally parse URL/line/column from eval frames\n    var geckoEval = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\n    var chromeEval = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\n    var lines = ex.stack.split('\\n');\n    var stack = [];\n    var submatch;\n    var parts;\n    var element;\n    var reference = /^(.*) is undefined$/.exec(ex.message);\n\n    for (var i = 0, j = lines.length; i < j; ++i) {\n      if ((parts = chrome.exec(lines[i]))) {\n        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line\n        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line\n        if (isEval && (submatch = chromeEval.exec(parts[2]))) {\n          // throw out eval line/column and use top-most line/column number\n          parts[2] = submatch[1]; // url\n          parts[3] = submatch[2]; // line\n          parts[4] = submatch[3]; // column\n        }\n        element = {\n          url: !isNative ? parts[2] : null,\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: isNative ? [parts[2]] : [],\n          line: parts[3] ? +parts[3] : null,\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if ((parts = winjs.exec(lines[i]))) {\n        element = {\n          url: parts[2],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: [],\n          line: +parts[3],\n          column: parts[4] ? +parts[4] : null\n        };\n      } else if ((parts = gecko.exec(lines[i]))) {\n        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        if (isEval && (submatch = geckoEval.exec(parts[3]))) {\n          // throw out eval line/column and use top-most line number\n          parts[3] = submatch[1];\n          parts[4] = submatch[2];\n          parts[5] = null; // no column when eval\n        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {\n          // FireFox uses this awesome columnNumber property for its top frame\n          // Also note, Firefox's column number is 0-based and everything else expects 1-based,\n          // so adding 1\n          // NOTE: this hack doesn't work if top-most frame is eval\n          stack[0].column = ex.columnNumber + 1;\n        }\n        element = {\n          url: parts[3],\n          func: parts[1] || UNKNOWN_FUNCTION,\n          args: parts[2] ? parts[2].split(',') : [],\n          line: parts[4] ? +parts[4] : null,\n          column: parts[5] ? +parts[5] : null\n        };\n      } else {\n        continue;\n      }\n\n      if (!element.func && element.line) {\n        element.func = UNKNOWN_FUNCTION;\n      }\n\n      if (element.url && element.url.substr(0, 5) === 'blob:') {\n        // Special case for handling JavaScript loaded into a blob.\n        // We use a synchronous AJAX request here as a blob is already in\n        // memory - it's not making a network request.  This will generate a warning\n        // in the browser console, but there has already been an error so that's not\n        // that much of an issue.\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET', element.url, false);\n        xhr.send(null);\n\n        // If we failed to download the source, skip this patch\n        if (xhr.status === 200) {\n          var source = xhr.responseText || '';\n\n          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.\n          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175\n          source = source.slice(-300);\n\n          // Now we dig out the source map URL\n          var sourceMaps = source.match(/\\/\\/# sourceMappingURL=(.*)$/);\n\n          // If we don't find a source map comment or we find more than one, continue on to the next element.\n          if (sourceMaps) {\n            var sourceMapAddress = sourceMaps[1];\n\n            // Now we check to see if it's a relative URL.\n            // If it is, convert it to an absolute one.\n            if (sourceMapAddress.charAt(0) === '~') {\n              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);\n            }\n\n            // Now we strip the '.map' off of the end of the URL and update the\n            // element so that Sentry can match the map to the blob.\n            element.url = sourceMapAddress.slice(0, -4);\n          }\n        }\n      }\n\n      stack.push(element);\n    }\n\n    if (!stack.length) {\n      return null;\n    }\n\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n  }\n\n  /**\n   * Adds information about the first frame to incomplete stack traces.\n   * Safari and IE require this to get complete data on the first frame.\n   * @param {Object.<string, *>} stackInfo Stack trace information from\n   * one of the compute* methods.\n   * @param {string} url The URL of the script that caused an error.\n   * @param {(number|string)} lineNo The line number of the script that\n   * caused an error.\n   * @param {string=} message The error generated by the browser, which\n   * hopefully contains the name of the object that caused the error.\n   * @return {boolean} Whether or not the stack information was\n   * augmented.\n   */\n  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {\n    var initial = {\n      url: url,\n      line: lineNo\n    };\n\n    if (initial.url && initial.line) {\n      stackInfo.incomplete = false;\n\n      if (!initial.func) {\n        initial.func = UNKNOWN_FUNCTION;\n      }\n\n      if (stackInfo.stack.length > 0) {\n        if (stackInfo.stack[0].url === initial.url) {\n          if (stackInfo.stack[0].line === initial.line) {\n            return false; // already in stack trace\n          } else if (\n            !stackInfo.stack[0].line &&\n            stackInfo.stack[0].func === initial.func\n          ) {\n            stackInfo.stack[0].line = initial.line;\n            return false;\n          }\n        }\n      }\n\n      stackInfo.stack.unshift(initial);\n      stackInfo.partial = true;\n      return true;\n    } else {\n      stackInfo.incomplete = true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Computes stack trace information by walking the arguments.caller\n   * chain at the time the exception occurred. This will cause earlier\n   * frames to be missed but is the only way to get any stack trace in\n   * Safari and IE. The top frame is restored by\n   * {@link augmentStackTraceWithInitialElement}.\n   * @param {Error} ex\n   * @return {?Object.<string, *>} Stack trace information.\n   */\n  function computeStackTraceByWalkingCallerChain(ex, depth) {\n    var functionName = /function\\s+([_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*)?\\s*\\(/i,\n      stack = [],\n      funcs = {},\n      recursion = false,\n      parts,\n      item,\n      source;\n\n    for (\n      var curr = computeStackTraceByWalkingCallerChain.caller;\n      curr && !recursion;\n      curr = curr.caller\n    ) {\n      if (curr === computeStackTrace || curr === TraceKit.report) {\n        // console.log('skipping internal function');\n        continue;\n      }\n\n      item = {\n        url: null,\n        func: UNKNOWN_FUNCTION,\n        line: null,\n        column: null\n      };\n\n      if (curr.name) {\n        item.func = curr.name;\n      } else if ((parts = functionName.exec(curr.toString()))) {\n        item.func = parts[1];\n      }\n\n      if (typeof item.func === 'undefined') {\n        try {\n          item.func = parts.input.substring(0, parts.input.indexOf('{'));\n        } catch (e) {}\n      }\n\n      if (funcs['' + curr]) {\n        recursion = true;\n      } else {\n        funcs['' + curr] = true;\n      }\n\n      stack.push(item);\n    }\n\n    if (depth) {\n      // console.log('depth is ' + depth);\n      // console.log('stack is ' + stack.length);\n      stack.splice(0, depth);\n    }\n\n    var result = {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref(),\n      stack: stack\n    };\n    augmentStackTraceWithInitialElement(\n      result,\n      ex.sourceURL || ex.fileName,\n      ex.line || ex.lineNumber,\n      ex.message || ex.description\n    );\n    return result;\n  }\n\n  /**\n   * Computes a stack trace for an exception.\n   * @param {Error} ex\n   * @param {(string|number)=} depth\n   */\n  function computeStackTrace(ex, depth) {\n    var stack = null;\n    depth = depth == null ? 0 : +depth;\n\n    try {\n      stack = computeStackTraceFromStackProp(ex);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n\n    try {\n      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);\n      if (stack) {\n        return stack;\n      }\n    } catch (e) {\n      if (TraceKit.debug) {\n        throw e;\n      }\n    }\n    return {\n      name: ex.name,\n      message: ex.message,\n      url: getLocationHref()\n    };\n  }\n\n  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;\n  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;\n\n  return computeStackTrace;\n})();\n\nmodule.exports = TraceKit;\n"]},"metadata":{},"sourceType":"script"}